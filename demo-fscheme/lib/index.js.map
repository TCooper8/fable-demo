{"version":3,"sources":["../src/index.fsx"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["#r \"../node_modules/fable-core/Fable.Core.dll\"\n\nopen System\nopen System.Numerics\n\ntype Token =\n    | Open | Close\n    | Quote | Unquote\n    | Number of string\n    | String of string\n    | Symbol of string\n\nlet tokenize source =\n    let rec string acc = function\n        | '\\\\' :: '\"' :: t -> string (acc + \"\\\"\") t // escaped quote becomes quote\n        | '\\\\' :: 'b' :: t -> string (acc + \"\\b\") t // escaped backspace\n        | '\\\\' :: 'f' :: t -> string (acc + \"\\f\") t // escaped formfeed\n        | '\\\\' :: 'n' :: t -> string (acc + \"\\n\") t // escaped newline\n        | '\\\\' :: 'r' :: t -> string (acc + \"\\r\") t // escaped return\n        | '\\\\' :: 't' :: t -> string (acc + \"\\t\") t // escaped tab\n        | '\\\\' :: '\\\\' :: t -> string (acc + \"\\\\\") t // escaped backslash\n        | '\"' :: t -> acc, t // closing quote terminates\n        | c :: t -> string (acc + (c.ToString())) t // otherwise accumulate chars\n        | _ -> failwith \"Malformed string.\"\n    let rec comment = function\n        | '\\r' :: t | '\\n' :: t -> t // terminated by line end\n        | [] -> [] // or by EOF\n        | _ :: t -> comment t\n    let rec token acc = function\n        | (')' :: _) as t -> acc, t // closing paren terminates\n        | w :: t when Char.IsWhiteSpace(w) -> acc, t // whitespace terminates\n        | [] -> acc, [] // end of list terminates\n        | c :: t -> token (acc + (c.ToString())) t // otherwise accumulate chars\n    let rec tokenize' acc = function\n        | w :: t when Char.IsWhiteSpace(w) -> tokenize' acc t // skip whitespace\n        | '(' :: t -> tokenize' (Open :: acc) t\n        | ')' :: t -> tokenize' (Close :: acc) t\n        | '\\'' :: t -> tokenize' (Quote :: acc) t\n        | ',' :: t -> tokenize' (Unquote :: acc) t\n        | ';' :: t -> comment t |> tokenize' acc // skip over comments\n        | '\"' :: t -> // start of string\n            let s, t' = string \"\" t\n            tokenize' (Token.String(s) :: acc) t'\n        | '-' :: d :: t when Char.IsDigit(d) -> // start of negative number\n            let n, t' = token (\"-\" + d.ToString()) t\n            tokenize' (Token.Number(n) :: acc) t'\n        | '+' :: d :: t | d :: t when Char.IsDigit(d) -> // start of positive number\n            let n, t' = token (d.ToString()) t\n            tokenize' (Token.Number(n) :: acc) t'\n        | s :: t -> // otherwise start of symbol\n            let s, t' = token (s.ToString()) t\n            tokenize' (Token.Symbol(s) :: acc) t'\n        | [] -> List.rev acc // end of list terminates\n    tokenize' [] source\n\ntype Expression =\n    | Number of BigInteger\n    | String of string\n    | Symbol of string\n    | List of Expression list\n    | Function of (Continuation -> Expression list -> Expression)\n    | Special of (Continuation -> Environment -> Expression list -> Expression)\n    | Current of Continuation\n    | Dummy of string\nand Continuation = Expression -> Expression\nand Frame = Map<string, Expression ref> ref\nand Environment = Frame list\n\nlet parse source =\n    let map = function\n        | Token.Number(n) -> Expression.Number(BigInteger.Parse(n))\n        | Token.String(s) -> Expression.String(s)\n        | Token.Symbol(s) -> Expression.Symbol(s)\n        | _ -> failwith \"Syntax error.\"\n    let rec list f t acc =\n        let e, t' = parse' [] t\n        parse' (List(f e) :: acc) t'\n    and parse' acc = function\n        | Open :: t -> list id t acc\n        | Close :: t -> (List.rev acc), t\n        | Quote :: Open :: t -> list (fun e -> [Symbol(\"quote\"); List(e)]) t acc\n        | Quote :: h :: t -> parse' (List([Symbol(\"quote\"); map h]) :: acc) t\n        | Unquote :: Open :: t -> list (fun e -> [Symbol(\"unquote\"); List(e)]) t acc\n        | Unquote :: h :: t -> parse' (List([Symbol(\"unquote\"); map h]) :: acc) t\n        | h :: t -> parse' ((map h) :: acc) t\n        | [] -> (List.rev acc), []\n    let result, _ = parse' [] (tokenize source)\n    result\n\nlet rec print = function\n    | List(Dummy(_) :: _) -> \"\" // don't print accumulated statement dummy values\n    | List(list) -> \"(\" + String.Join(\" \", (List.map print list)) + \")\"\n    | String(s) | Symbol(s) -> s\n    | Number(n) -> n.ToString()\n    | Function(_) | Special(_) | Current(_) -> \"Function\"\n    | Dummy(_) -> \"\" // sometimes useful to emit value for debugging, but normally we ignore\n\nlet malformed n e = sprintf \"Malformed '%s': %s\" n (print (List([e]))) |> failwith\n\nlet math ident unary op name cont = function\n    | [] -> Number(ident) |> cont // (op) == 0\n    | [Number(n)] -> Number(unary * n) |> cont // (op a) == -a or +a\n    | Number(n) :: ns -> // (op a b c) == a op b op c\n        let op' a = function Number(b) -> op a b | m -> malformed (sprintf \"%s arg\" name) m\n        Number(List.fold op' n ns) |> cont\n    | m -> malformed name (List(m))\n\nlet SchemeList cont = function\n  | ns -> List(ns) |> cont\n\nlet Nil cont = function\n  | [] -> List([]) |> cont\n\nlet Add = math 0I 1I (+) \"addition\"\nlet Subtract = math 0I -1I (-) \"subtraction\"\nlet Multiply = math 1I 1I (*) \"multiplication\"\nlet Divide = math 1I 1I (/) \"division\"\nlet Modulus = math 1I 1I (%) \"modulus\"\n\nlet compare pred name cont = function\n    | [Number(a); Number(b)] -> (if pred a b then Number(1I) else Number(0I)) |> cont\n    | m -> malformed name (List(m))\n\nlet Equal = compare (=) \"equality\"\nlet Greater = compare (>) \"greater\"\nlet Less = compare (<) \"less\"\n\nlet extend env bindings = (ref (Map.ofList bindings) :: env)\nlet lookup env symbol =\n    match List.tryPick (fun (frame : Frame) -> Map.tryFind symbol frame.Value) env with\n    | Some(e) -> e\n    | None -> sprintf \"No binding for '%s'.\" symbol |> failwith\n\nlet zip args parameters =\n    let args' = // passing more args than params results in last param treated as list\n        let plen = List.length parameters\n        if List.length args = plen then args else\n            let split ts = ts (plen - 1) args |> List.ofSeq\n            split Seq.take @ [List(split Seq.skip)]\n    List.zip parameters args'\n\nlet mutable backtrack = [] // ambivalent back stack\n\nlet rec If cont env = function\n    | [condition; t; f] ->\n        interp (function\n            | List([]) | String(\"\") -> interp cont env f // empty list or empty string is false\n            | Number(n) when n = 0I -> interp cont env f // zero is false\n            | _ -> interp cont env t) env condition // everything else is true\n    | m -> malformed \"if\" (List(m))\n\nand Let cont env = function\n    | [List(bindings); body] ->\n        let rec mapbind acc = function\n            | List([Symbol(s); e]) :: t -> interp (fun x -> mapbind ((s, ref x) :: acc) t) env e\n            | [] ->\n                let frame = List.rev acc\n                let env' = extend env frame\n                interp cont env' body\n            | _ -> failwith \"Malformed 'let' binding.\"\n        mapbind [] bindings\n    | m -> malformed \"let\" (List(m))\n\nand LetRec cont env = function\n    | [List(bindings); body] ->\n        let bind = function List([Symbol(s); _]) -> s, ref (Dummy(\"Dummy 'letrec'\")) | m -> malformed \"letrec binding\" m\n        let env' = List.map bind bindings |> extend env\n        let frame = env'.Head.Value\n        // now update dummy env - assumes dummy env will be captured but not actually accessed (e.g. lambda)\n        let rec mapupdate = function\n            | List([Symbol(s); e]) :: t -> interp (fun x -> (frame.Item s) := x; mapupdate t) env' e\n            | [] -> interp cont env' body\n            | _ -> failwith \"Malformed 'let' binding.\"\n        mapupdate bindings\n    | m -> malformed \"letrec\" (List(m))\n\nand LetStar cont env = function\n    | [List(bindings); body] ->\n        let rec foldbind env' = function\n            | List([Symbol(s); e]) :: t -> interp (fun x -> foldbind ([s, ref x] |> extend env') t) env' e\n            | [] ->interp cont env' body\n            | _ -> failwith \"Malformed 'let*' binding.\"\n        foldbind env bindings\n    | m -> malformed \"let*\" (List(m))\n\nand Lambda cont env = function\n    | [List(parameters); body] ->\n        let closure cont' env' args =\n            // bind parameters to actual arguments (interpuated in the caller's environment)\n            let rec mapbind acc = function\n                | (Symbol(p), a) :: t -> interp (fun x -> mapbind ((p, ref x) :: acc) t) env' a\n                | [] ->\n                    let env'' = List.rev acc |> extend (env @ env') // extend the captured definition-time environment\n                    interp cont' env'' body\n                | _ -> failwith \"Malformed lambda param.\"\n            mapbind [] (zip args parameters)\n        Special(closure) |> cont\n    | m -> malformed \"lambda\" (List(m))\n\nand Cat cont = function [List(a); List(b)] -> List(a @ b) |> cont | m -> malformed \"cat\" (List(m))\nand Cons cont = function [h; List(t)] -> (List(h :: t)) |> cont | m -> malformed \"cons\" (List(m))\nand Car cont = function [List(h :: _)] -> h |> cont | m -> malformed \"car\" (List(m))\nand Cdr cont = function [List(_ :: t)] -> List(t) |> cont | m -> malformed \"cdr\" (List(m))\n\nand Quote cont env =\n    let rec unquote cont' = function\n        | List([Symbol(\"unquote\"); e]) -> interp cont' env e\n        | List(Symbol(\"unquote\") :: _) as m -> malformed \"unquote (too many args)\" m\n        | List(lst) ->\n            let rec mapunquote acc = function\n                | h' :: t' ->\n                    unquote (fun x -> mapunquote (x :: acc) t') h'\n                | [] -> List(List.rev acc)\n            mapunquote [] lst |> cont'\n        | e -> cont' e\n    function [e] -> unquote cont e | m -> malformed \"quote\" (List(m))\n\nand Eval cont env = function [args] -> args |> interp (interp cont env) env | m -> malformed \"interp\" (List(m))\n\nand Macro cont env = function\n    | [List(parameters); body] ->\n        let closure cont' env' args =\n            // bind parameters to actual arguments (but uninterpuated, unlike lambda)\n            let bind = function Symbol(p), a -> p, ref a | _, m -> malformed \"macro parameter\" m // bound uninterpuated\n            let env'' = zip args parameters |> List.map bind |> extend env // extend the captured definition-time environment\n            interp (interp cont' env') env'' body\n        Special(closure) |> cont\n    | m -> malformed \"macro\" (List(m))\n\nand Set cont env = function\n    | [Symbol(s); e] -> interp (fun x -> (lookup env s) := x; Dummy(sprintf \"Set %s\" s) |> cont) env e\n    | m -> malformed \"set!\" (List(m))\n\nand Begin cont env =\n    let rec foldinterp last = function\n        | h :: t -> interp (fun x -> foldinterp x t) env h\n        | [] -> last |> cont\n    foldinterp (Dummy(\"Empty 'begin'\"))\n\nand Define cont (env : Environment) = function\n    | [Symbol(s); e] ->\n        let def = ref (Dummy(\"Dummy 'define'\"))\n        env.Head := Map.add s def env.Head.Value\n        interp (fun x -> def := x; Dummy(sprintf \"Defined %s\" s) |> cont) env e\n    | m -> malformed \"define\" (List(m))\n\nand Display cont = function\n    | [e] -> print e |> printfn \"%s\"; Dummy(\"Dummy 'display'\") |> cont\n    | m -> malformed \"display\" (List(m))\n\nand CallCC cont env = function\n    | [callee] -> interp (function Special(fn) -> fn cont env [Current(cont)] | m -> malformed \"call/cc\" m) env callee\n    | m -> malformed \"call/cc\" (List(m))\n\nand Ambivalent cont env args =\n    match args with\n    | choice :: t ->\n        backtrack <- (fun () -> Ambivalent cont env t) :: backtrack\n        interp cont env choice\n    | [] ->\n        match backtrack with\n        | back :: t -> backtrack <- t; back ()\n        | [] -> printfn \"No more solutions.\"; Dummy(\"Unsolvable\") |> cont\n\nand environment =\n    [ref (Map.ofList\n       [\"*\", ref (Function(Multiply))\n        \"/\", ref (Function(Divide))\n        \"%\", ref (Function(Modulus))\n        \"+\", ref (Function(Add))\n        \"-\", ref (Function(Subtract))\n        \"=\", ref (Function(Equal))\n        \">\", ref (Function(Greater))\n        \"<\", ref (Function(Less))\n        \"if\", ref (Special(If))\n        \"let\", ref (Special(Let))\n        \"letrec\", ref (Special(LetRec))\n        \"let*\", ref (Special(LetStar))\n        \"lambda\", ref (Special(Lambda))\n        \"list\", ref (Function(SchemeList))\n        \"nil\", ref (Function(Nil))\n        \"cat\", ref (Function(Cat))\n        \"cons\", ref (Function(Cons))\n        \"car\", ref (Function(Car))\n        \"cdr\", ref (Function(Cdr))\n        \"quote\", ref (Special(Quote))\n        \"interp\", ref (Special(Eval))\n        \"macro\", ref (Special(Macro))\n        \"set!\", ref (Special(Set))\n        \"begin\", ref (Special(Begin))\n        \"define\", ref (Special(Define))\n        \"display\", ref (Function(Display))\n        \"call/cc\", ref (Special(CallCC))\n        \"amb\", ref (Special(Ambivalent))\n        ])]\n\nand interp cont env expression =\n    match expression with\n    | Number(_) | String(_) | Current(_) as lit -> lit |> cont\n    | Symbol(s) -> (lookup env s).Value |> cont\n    | List(h :: t) ->\n        interp (function\n            | Function(f) -> apply cont env f t\n            | Special(f) -> f cont env t\n            | Current(f) -> match t with [rtn] -> f rtn | m -> malformed \"call/cc args\" (List(m))\n            | m -> malformed \"expression\" m) env h\n    | Dummy(s) -> sprintf \"Cannot interpuate dummy value: %s\" s |> failwith\n    | _ -> failwith \"Malformed expression.\"\n\nand apply cont env fn args =\n    let rec mapinterp acc = function\n        | h :: t -> interp (fun a -> mapinterp (a :: acc) t) env h\n        | [] -> fn cont (List.rev acc)\n    mapinterp [] args\n\nlet rep env =\n    let interp' = function\n        | Symbol(\"?\") ->\n            match backtrack with\n            | h :: t -> backtrack <- t; h ()\n            | [] -> printfn \"No current problem.\"; Dummy(\"No problem\")\n        | e -> interp id env e\n    List.ofSeq >> parse >> List.head >> interp' >> print\n\nlet test () =\n    let case source expected =\n        try\n            let output = rep environment source\n            if output <> expected then\n                printfn \"TEST FAILED: %s [Expected: %s, Actual: %s]\" source expected output\n        with ex -> printfn \"TEST CRASHED: %s [%s]\" ex.Message source\n    case \"\\\"hello\\\"\" \"hello\" // strings\n    case \"\\\"\\\\\\\"\\\"\" \"\\\"\" // return char\n    case \"\\\"\\\\b\\\"\" \"\\b\" // return char\n    case \"\\\"\\\\f\\\"\" \"\\f\" // return char\n    case \"\\\"\\\\n\\\"\" \"\\n\" // return char\n    case \"\\\"\\\\r\\\"\" \"\\r\" // return char\n    case \"\\\"\\\\t\\\"\" \"\\t\" // return char\n    case \"\\\"\\\\\\\\\\\"\" \"\\\\\" // return char\n    case \"1\" \"1\" // numbers\n    case \"+1\" \"1\" // explicit positive numbers\n    case \"-1\" \"-1\" // negative numbers\n    case \"(*)\" \"1\" // multiplication\n    case \"(* 2)\" \"2\" // multiplication\n    case \"(* 2 3)\" \"6\" // multiplication\n    case \"(* 2 3 4)\" \"24\" // multiplication\n    case \"(/)\" \"1\" // division\n    case \"(/ 2)\" \"2\" // division\n    case \"(/ 9 2)\" \"4\" // division\n    case \"(/ 12 2 3)\" \"2\" // division\n    case \"(%)\" \"1\" // modulus\n    case \"(% 2)\" \"2\" // modulus\n    case \"(% 9 2)\" \"1\" // modulus\n    case \"(% 8 2)\" \"0\" // modulus\n    case \"(% 26 7 3)\" \"2\" // modulus\n    case \"(+)\" \"0\" // strange addition case\n    case \"(+ 10)\" \"10\" // explicit positive\n    case \"(+ 10 2)\" \"12\" // addition\n    case \"(+ 10 2 3)\" \"15\" // addition\n    case \"(-)\" \"0\" // strange subtraction case\n    case \"(- 10)\" \"-10\" // negation\n    case \"(- 10 2)\" \"8\" // subtraction\n    case \"(- 10 2 3)\" \"5\" // subtraction\n    case \"(if (* 0 1) 10 20)\" \"20\" // if\n    case \"(if (* 1 1) 10 20)\" \"10\" // if\n    case \"(if (* 1 1) 10 bomb)\" \"10\" // if (special form)\n    case \"(* 1234567890987654321 1234567890987654321)\" \"1524157877457704723228166437789971041\" // bigint math\n    case \"(let ((x 2)) x)\" \"2\" // simple let\n    case \"(let ((a 00) (b 10) (c 20)) (if a b c))\" \"20\" // conditional interp\n    case \"(let ((square (lambda (x) (* x x)))) (square 4))\" \"16\" // lambda\n    case \"(let ((square (lambda (x) (* x x)))) square)\" \"Function\" // print lambda\n    case \"(let ((times3 (let ((n 3)) (lambda (x) (* n x))))) (times3 4))\" \"12\" // closure\n    case \"(let ((times3 (let ((makemultiplier (lambda (n) (lambda (x) (* n x))))) (makemultiplier 3)))) (times3 5))\" \"15\" // higher order functions\n    case \"(letrec ((factorial (lambda (n) (if n (* n (factorial (- n 1))) 1)))) (factorial 4))\" \"24\" // letrec and recursion\n    case \"(let ((a 1) (b 2)) (let ((a b) (b a)) b))\" \"1\" // let binds in parallel (should work in earlier versions too)\n    case \"(let ((a 1) (b 2)) (let* ((a b) (b a)) b))\" \"2\" // let* binds sequentially\n    case \"(let ((a 5)) (let ((b (* a 2))) (let ((c (- b 3))) c)))\" \"7\" // poor-man's sequential expressions\n    case \"(let* ((a 5) (b (* a 2)) (c (- b 3))) c)\" \"7\" // let* sequential expressions\n    case \"(list 1 2 3)\" \"(1 2 3)\" // list\n    case \"(car (list 1 2 3))\" \"1\" // car\n    case \"(cdr (list 1 2 3))\" \"(2 3)\" // cdr\n    case \"(cat '(1 2) '(a b))\" \"(1 2 a b)\" // cat\n    case \"(cat '(1 2) '())\" \"(1 2)\" // cat\n    case \"(cat '() '(1 2))\" \"(1 2)\" // cat\n    case \"(cons 1 (list 2 3))\" \"(1 2 3)\" // cons\n    case \"(cons 1 (cons 2 (cons 3 nil)))\" \"(1 2 3)\" // cons x3\n    case \"(let ((a 1) (b 2) (c 3)) (list a b c))\" \"(1 2 3)\" // list\n    case \"(let ((a (list 1 2 3))) (car a))\" \"1\" // car\n    case \"(let ((a (list 1 2 3))) (cdr a))\" \"(2 3)\" // cdr\n    case \"(quote (* 2 3))\" \"(* 2 3)\" // quote primitive\n    case \"'(* 2 3)\" \"(* 2 3)\" // quote primitive with sugar\n    case \"(interp '(* 2 3))\" \"6\" // interp quoted expression\n    case \"(quote (* 2 (- 5 2)))\" \"(* 2 (- 5 2))\" // quote nested\n    case \"(quote (* 2 (unquote (- 5 2))))\" \"(* 2 3)\" // quote nested unquote\n    case \"'(* 2 ,(- 5 2))\" \"(* 2 3)\" // quote nested unquote with sugar\n    case \"(quote (quote 1 2 3))\" \"(quote 1 2 3)\" // quote special form\n    case \"(let ((x 'rain) (y 'spain) (z 'plain)) '(the ,x in ,y falls mainly on the ,z))\"\n         \"(the rain in spain falls mainly on the plain)\" // quote/unquote\n    case \"(let ((or (macro (a b) '(if ,a 1 (if ,b 1 0))))) (or 1 BOOM))\" \"1\" // macro as special form\n    case \"(let ((and (macro (a b) '(if ,a (if ,b 1 0) 0)))) (and 0 BOOM))\" \"0\" // macro as special form\n    case \"(let ((a 1)) (begin (set! a 2) a))\" \"2\" // begin and assign\n    case \"(let* ((a 5) (dummy (set! a 10))) a)\" \"10\" // re-assign after let\n    case \"(begin (define fac (lambda (x) (if x (* x (fac (- x 1))) 1))) (fac 7))\" \"5040\" // define recursive\n    case \"(begin (define square (lambda (x) (* x x))) (square 4))\" \"16\" // global def\n    case \"(let ((x 4)) (begin (define y 8) (* x y))))\" \"32\" // local def\n    case \"(and 0 0)\" \"0\" // or (false)\n    case \"(and 1 0)\" \"0\" // or (false)\n    case \"(and 0 1)\" \"0\" // or (false)\n    case \"(and 1 1)\" \"1\" // or (true)\n    case \"(or 0 0)\" \"0\" // or (false)\n    case \"(or 1 0)\" \"1\" // or (true)\n    case \"(or 0 1)\" \"1\" // or (true)\n    case \"(or 1 1)\" \"1\" // or (true)\n    case \"(not? 0)\" \"1\" // or (true)\n    case \"(not? 1)\" \"0\" // or (false)\n    case \"(xor 0 0)\" \"0\" // xor (false)\n    case \"(xor 1 0)\" \"1\" // xor (true)\n    case \"(xor 0 1)\" \"1\" // xor (true)\n    case \"(xor 1 1)\" \"0\" // xor (false)\n    case \"(let ((square (lambda (x) (* x x)))) (map square '(1 2 3 4 5 6 7 8 9)))\" \"(1 4 9 16 25 36 49 64 81)\" // mapping\n    case \"(let ((square (lambda (x) (* x x)))) (map square '(9)))\" \"(81)\" // mapping single\n    case \"(let ((square (lambda (x) (* x x)))) (map square '()))\" \"()\" // mapping empty\n    case \"(fold * 1 '(2 3 4 5))\" \"120\" // fold\n    case \"(reverse '(1 2 3))\" \"(3 2 1)\" // reverse\n    case \"(call/cc (lambda (c) (c 10)))\" \"10\" // super-simple call/cc\n    case \"(call/cc (lambda (c) (if (c 10) 20 30)))\" \"10\" // call/cc bailing out of 'if'\n    case \"(+ 8 (call/cc (lambda (k^) (* (k^ 5) 100))))\" \"13\" // call/cc bailing out of multiplication\n    case \"(* (+ (call/cc (lambda (k^) (/ (k^ 5) 4))) 8) 3)\" \"39\" // call/cc nesting\n//test ()\n"]}